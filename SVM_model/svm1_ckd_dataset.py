# -*- coding: utf-8 -*-
"""SVM1_CKD_dataset.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1epHz-5WCE8CmeF-vjti3cJ5SqR0hyKhM

# **Data Preprocessing**
"""

import pandas as pd
import numpy as py

df = pd.read_csv('CDK_final_dataset.csv')

#drop
df.drop(['Albumin_to_Creatinine_Ratio','Glomerular_Filtration_Rate'],axis=1,inplace=True)

df.shape

df.head()

df.tail()

df.info()

df.describe()

df.describe().T

"""# **value counts of Target**"""

color_wheel = {1: "#0392cf",
               2: "#7bc043"}
colors = df["Target"].map(lambda x: color_wheel.get(x + 1))
print(df.Target.value_counts())
p=df.Target.value_counts().plot(kind="bar")

import seaborn as sns
import matplotlib.pyplot as plt
corrmat=df.corr()
sns.heatmap(corrmat, annot=True, linewidths=0.3, fmt='.2g', annot_kws={'size': 5})

from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split


X = df.drop(columns=["Target"])
y = df["Target"]
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)


scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)


X_train_scaled = pd.DataFrame(X_train_scaled, columns=X.columns)
X_test_scaled = pd.DataFrame(X_test_scaled, columns=X.columns)

"""# **Support Vector Machine**"""

from sklearn.model_selection import RepeatedStratifiedKFold
from sklearn.model_selection import GridSearchCV
from sklearn.svm import SVC
from sklearn.metrics import classification_report,confusion_matrix
from sklearn.metrics import f1_score, precision_score, recall_score

model = SVC(probability=True)
kernel = ['poly', 'rbf', 'sigmoid']
C = [50, 10, 1.0, 0.1, 0.01]
gamma = ['scale']

# define grid search
grid = dict(kernel=kernel,C=C,gamma=gamma)
cv = RepeatedStratifiedKFold(n_splits=10, n_repeats=3, random_state=1)
grid_search = GridSearchCV(estimator=model, param_grid=grid, n_jobs=-1, cv=cv, scoring='f1',error_score=0)

grid_result = grid_search.fit(X_train_scaled,y_train)

svm_pred=grid_result.predict(X_test_scaled)

train_accuracy = grid_result.score(X_train_scaled, y_train)


test_accuracy = grid_result.score(X_test_scaled, y_test)

print(f"Training Accuracy: {train_accuracy:.2f}")
print(f"Testing Accuracy: {test_accuracy:.2f}")

if train_accuracy - test_accuracy > 0.1:
    print("The model might be overfitting!")

import matplotlib.pyplot as plt
from sklearn.metrics import roc_curve, roc_auc_score
import seaborn as sns


print("Classification Report is:\n",classification_report(y_test,svm_pred))
print("\n F1:\n",f1_score(y_test,svm_pred))
print("\n Precision score is:\n",precision_score(y_test,svm_pred))
print("\n Recall score is:\n",recall_score(y_test,svm_pred))
print("\n Confusion Matrix:\n")
plt.figure(figsize=(6, 4))
sns.heatmap(
    confusion_matrix(y_test, svm_pred),
    annot=True,
    fmt='d',
    cmap='Blues',
    xticklabels=['No CDK', 'CDK'],
    yticklabels=['No CDK', 'CDK']
)
plt.title('Confusion Matrix', fontsize=14)
plt.xlabel('Predicted', fontsize=12)
plt.ylabel('Actual', fontsize=12)
plt.show()

from sklearn.metrics import roc_curve, roc_auc_score
import matplotlib.pyplot as plt

rf_probabilities = grid_result.predict_proba(X_test_scaled)[:, 1]

roc_auc = roc_auc_score(y_test, rf_probabilities)
print(f"ROC-AUC: {roc_auc:.2f}")


fpr, tpr, thresholds = roc_curve(y_test, rf_probabilities)


plt.figure(figsize=(8, 6))
plt.plot(fpr, tpr, color='blue', label=f'ROC curve (AUC = {roc_auc:.2f})')
plt.plot([0, 1], [0, 1], color='gray', linestyle='--')
plt.title('ROC Curve', fontsize=14)
plt.xlabel('False Positive Rate (FPR)', fontsize=12)
plt.ylabel('True Positive Rate (TPR)', fontsize=12)
plt.legend(loc='lower right')
plt.grid()
plt.show()

import pickle

with open('svm_model.pkl', 'wb') as file:
    pickle.dump(grid_result.best_estimator_, file)

print("done pickle!")

# Restore the model
"""with open('svm_model.pkl', 'rb') as file:
    loaded_model = pickle.load(file)

# Test the restored model
loaded_model_predictions = loaded_model.predict(X_test)
print("Done\n", loaded_model_predictions)"""